

<div class="orbitron">More Data At Once</div>
<div class="m24">
        <p>
                The library organizes each implementation's navigation options in the user-interface as a map to everything. Table of Contents, content filters, and category links all assist in guiding the user through the whole dataset.
        </p>
        <p>Query results are optimized for <em>data-immediacy</em>, exposing all data directly within the results page. This eliminates back-and-forth page traversal by eliminating the full-details page.</p>

        <p>The exposure of full-data on every record in view is as functional as it is aesthetic. The content volume occupies comfortable amounts of space, while the data is made readably dense, like that of Japanese product packaging.  </p>
        <p>
                Full-data output runs the risk of data-overabundance. Vertical spacing is maintained with various content collapsing methods. Long text is collapsed into description containers with <em>show-more</em> toggles. Panels are tabbed in order to alter context within the same space, which both introduces and relieves layout shifting.
        </p>
</div>

<div class="orbitron">Pagination</div>
<div class="m24">
        <p>
        The library uses offset pagination for smaller datasets. For deep paging, both keyset and offset pagination are used together. The page-limit is curated for each implementation based on the average html output length of a query. Art museums mostly show 20 records per query due to their meta-data and thumbnail richness. Implementations with less meta-data output will show a higher number of records.
</p>
</div>

<div class="orbitron">Lazy Loading</div>
<div class="m24">
        Lazy loading of images at the library is primarily for respecting online traffic. It was forced into creation when viewing <em>The Smithsonian Field Book Project</em>, which is a department from The Smithsonian that has dozens of thumbnails per record. Even with a 20 record limit per page, the amount of thumbnails forced rate-limiting from the image server (IDS) against the IP-address in which data was being received. Deferring the loading based on viewing proximity solved the issue and lazy loading has since been implemented into nearly every dataset.
</div>

<div class="orbitron">Earliest Filter</div>
<div class="m24">
        Data for commercial products, such as those from AniList (anime data) and IGDB (video games data), usually prioritize the display of new or upcoming records at their establishments. The library is concerned with historical records also. The <em>earliest</em> filter is critical despite being innocuous. It makes historical browsing relevant. By browsing AniList for 60's animations, one will find that a lot of them are made available to watch on Youtube. AniList does not know that this data is available for linkage, although with just a little bit more curiosity, one can start at the library and find their way to old animations which are otherwise lost to time.
</div>

<div class="orbitron">Fetch-Links</div>
<div class="m24">
        <p>In December of 2025, a new <em>fetch</em> system was implemented for increase in access to specific slices in a dataset. The most common filters are the order filters : popularity/rating, latest, earliest, and random. Another common filter is date-range. These filters naturally allow one to narrow down category and search queries. New to the mix however is the <em>fetch</em> link which is conditional. It appears when clicking on the random toggle of the <em>order</em> filter-set or any <em>date-range</em> filter that is not &quot;all&quot;. Clicking on the fetch-link will query the database without category recognition and assume the entire dataset as relevant.</p>
        <p>The results of a <em>fetch</em> differ based on the context of the fetch-link. <em>Random :: Fetch</em> will get random records and limit the count to 400. This is also additive with the date-range filter. <em> Date-Range :: Fetch</em> will get all records within the date-range, while also being additive with the order filter. Without the fetch-links, these filters were originally only useful for slicing into categories. Now with fetch-links, datasets are now sliceable in more ways, leading to more control over what someone can achieve in a query. All datasets which can benefit from fetch-links will be updated to support this new system.</p>
</div>